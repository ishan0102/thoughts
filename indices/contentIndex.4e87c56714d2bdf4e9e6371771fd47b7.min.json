{"/":{"title":"ðŸª´ Ishan's Garden","content":"\nThis is a space for me to hold my thoughts. I plan on adding notes about what I'm currently learning, various software topics I've always wanted to discuss, and other random musings.\n\nYou can read my notes in a variety of ways. Click [here](/notes) to view the notes as a list, play with the interactive graph below, or `Control` + `K` to search the entire site.\n\nSo far, I've written about the following topics:\n- [Code Snippets](notes/CodeSnippets.md): A collection of code snippets I use frequently.\n","lastmodified":"2022-05-15T08:25:34.333181697Z","tags":null},"/notes/CodeSnippets":{"title":"Code Snippets","content":"\nOn this page I plan on documenting all the code snippets I use frequently. I'll use `T` for generic types, `K` for generic keys, and `V` for generic values when necessary. All of this code is written in `Java` since I think it's the most user-friendly.\n\n# `HashMap` Iteration\n```java\npublic void iterateHashMap(HashMap\u003cK, V\u003e map) {\n    for (Map.Entry\u003cK, V\u003e entry : map.entrySet()) {\n        entry.getKey();\n        entry.getValue();\n    }\n}\n```\n\n# Depth-First Search\n```java\npublic void dfs(HashSet\u003cNode\u003e visited, Node root) {\n    if (root == null) {\n        return;\n    }\n\n    visited.add(root);\n    for (Node child : root.children) {\n        if (!visited.contains(child)) {\n            dfs(visited, child);\n        }\n    }\n}\n\n```\n*This can be done iteratively with a stack instead of recursively.*\n\n# Breadth-First Search\n```java\npublic void bfs(Node root) {\n    HashSet\u003cNode\u003e visited = new HashSet\u003c\u003e();\n    Queue\u003cNode\u003e queue = new LinkedList\u003cNode\u003e();\n    queue.add(root);\n\n    while (!queue.isEmpty()) {\n        Node curr = queue.poll();\n        for (Node child : curr.children) {\n            if (!visited.contains(child)) {\n                queue.add(child);\n                visited.add(child);\n            }\n        }\n    }\n}\n```\n\n# Level-Order Traversal\n```java\npublic void levelOrder(Node root) {\n    HashSet\u003cNode\u003e visited = new HashSet\u003c\u003e();\n    Queue\u003cNode\u003e queue = new LinkedList\u003cNode\u003e();\n    queue.add(root);\n\n    int level = 0;\n    while (!queue.isEmpty()) {\n        int size = queue.size();\n        for (int i = 0; i \u003c size; i++) {\n            Node curr = queue.poll();\n            for (Node child : curr.children) {\n                if (!visited.contains(child)) {\n                    queue.add(child);\n                    visited.add(child);\n                }\n            }\n        }\n        level++;\n    }\n}\n```\n*Level-order traversals differ from BFS because they keep track of what \"step\" of the BFS we're currently on. This can be handy for problems where we want to know the length of the shortest path, like [Word Ladder](https://leetcode.com/problems/word-ladder/) or [Rotting Oranges](https://leetcode.com/problems/rotting-oranges/)*.\n","lastmodified":"2022-05-15T08:25:34.333181697Z","tags":null}}