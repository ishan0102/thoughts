{"/":{"title":"Ishan's Garden","content":"\nThis is a space for me to grow my thoughts. I plan on adding notes about what I'm currently learning, various software topics I've always wanted to discuss, and other random musings. You can read my notes in a variety of ways. There's an interactive graph at the bottom that lets you see how different notes relate to each other. You can also use `Control` + `K` to search the entire site. \n\nOr, browse all of my notes here:\n\u003e ### [Read the notes!](/notes)\n\nHere are some of my favorite ones:\n- [Code Snippets](notes/CodeSnippets.md): A collection of code snippets I use frequently.\n- [Bionic Reading](notes/BionicReading.md): Demonstrating a new way to read.\n","lastmodified":"2022-05-22T06:03:58.245408367Z","tags":null},"/notes/BionicReading":{"title":"Bionic Reading","content":"\n**Turn on light mode for the best experience!**\n\nRead the following paragraph:\n\u003e Bionic Reading is a new method facilitating the reading process by guiding the eyes through text with artificial fixation points. As a result, the reader is only focusing on the highlighted initial letters and lets the brain center complete the word. In a digital world dominated by shallow forms of reading, Bionic Reading aims to encourage a more in-depth reading and understanding of written content.\n\nNow, read it again:\n\u003e **Bio**nic **Read**ing **i**s **a** **ne**w **met**hod **facili**tating **t**he **read**ing **proc**ess **b**y **guid**ing **t**he **ey**es **thro**ugh **te**xt **wi**th **artif**icial **fixa**tion **poi**nts. **A**s **a** **res**ult, **t**he **rea**der **i**s **on**ly **focu**sing **o**n **t**he **highli**ghted **init**ial **lett**ers **a**nd **le**ts **t**he **bra**in **cen**ter **comp**lete **t**he **wo**rd. **I**n **a** **digi**tal **wor**ld **domin**ated **b**y **shal**low **for**ms **o**f **read**ing, **Bio**nic **Read**ing **ai**ms **t**o **encou**rage **a** **mo**re **i**n-**dep**th **read**ing **a**nd **underst**anding **o**f **writ**ten **cont**ent.\n\nIf this demo worked for you, you should've noticed that you blazed through the second paragraph compared to the first. [Bionic Reading](https://bionic-reading.com/) is a startup founded by Renato Casutt, which I discovered from [this tweet](https://twitter.com/juanbuis/status/1526900107379105793?s=20\u0026t=oNO87_mqH0x8BHOawmL1Jw). Unfortunately, the proprietary software is patented and is available [via API](https://rapidapi.com/bionic-reading-bionic-reading-default/api/bionic-reading1/), but the free tier is limited to a maximum of 500 requests per day. \n\nI found a [naive implementation](https://codesandbox.io/s/agitated-taussig-zfppc7?file=/pages/index.tsx) of this idea online, and I think it would be really interesting to build into a Chrome extension or something. Personally, I'd probably get through books and articles way faster with this, so I'll look into developing something when I have some free time.\n","lastmodified":"2022-05-22T06:03:58.245408367Z","tags":null},"/notes/CodeSnippets":{"title":"Code Snippets","content":"\nOn this page I plan on documenting all the code snippets I use frequently. I'll use `T` for generic types, `K` for generic keys, and `V` for generic values when necessary. All of this code is written in `Java` since I think it's the most user-friendly.\n\n## Maps\n\n### `HashMap` Iteration\n```java\npublic void iterateHashMap(HashMap\u003cK, V\u003e map) {\n    for (Map.Entry\u003cK, V\u003e entry : map.entrySet()) {\n        System.out.println(entry.getKey());\n        System.out.println(entry.getValue());\n    }\n}\n```\n\n## Trees\n\n### In-Order Traversal\n```java\npublic void inOrder(Node root) {\n    if (root == null) {\n        return;\n    }\n\n    inOrder(root.left);\n    System.out.println(root.val);\n    inOrder(root.right);\n}\n```\n\n### Pre-Order Traversal\n```java\npublic void preOrder(Node root) {\n    if (root == null) {\n        return;\n    }\n\n    System.out.println(root.val);\n    preOrder(root.left);\n    preOrder(root.right);\n}\n```\n\n### Post-Order Traversal\n```java\npublic void postOrder(Node root) {\n    if (root == null) {\n        return;\n    }\n\n    postOrder(root.left);\n    postOrder(root.right);\n    System.out.println(root.val);\n}\n```\n\n### Level-Order Traversal\n```java\npublic void levelOrder(Node root) {\n    Queue\u003cNode\u003e queue = new LinkedList\u003cNode\u003e();\n    queue.add(root);\n\n    while (!queue.isEmpty()) {\n        int size = queue.size();\n        for (int i = 0; i \u003c size; i++) {\n            Node curr = queue.poll();\n            System.out.println(curr.val);\n            queue.add(curr.left);\n            queue.add(curr.right);\n        }\n    }\n}\n```\n\n## Graphs\n\n### Depth-First Search\n```java\npublic void dfs(HashSet\u003cNode\u003e visited, Node root) {\n    if (root == null) {\n        return;\n    }\n\n    visited.add(root);\n    for (Node child : root.children) {\n        if (!visited.contains(child)) {\n            dfs(visited, child);\n        }\n    }\n}\n\n```\n*This can be done iteratively with a stack instead of recursively.*\n\n### Breadth-First Search\n```java\npublic void bfs(Node root) {\n    HashSet\u003cNode\u003e visited = new HashSet\u003c\u003e();\n    Queue\u003cNode\u003e queue = new LinkedList\u003cNode\u003e();\n    queue.add(root);\n\n    while (!queue.isEmpty()) {\n        Node curr = queue.poll();\n        for (Node child : curr.children) {\n            if (!visited.contains(child)) {\n                queue.add(child);\n                visited.add(child);\n            }\n        }\n    }\n}\n```\n\n### Level-Order Traversal\n```java\npublic void levelOrder(Node root) {\n    HashSet\u003cNode\u003e visited = new HashSet\u003c\u003e();\n    Queue\u003cNode\u003e queue = new LinkedList\u003cNode\u003e();\n    queue.add(root);\n\n    int level = 0;\n    while (!queue.isEmpty()) {\n        int size = queue.size();\n        for (int i = 0; i \u003c size; i++) {\n            Node curr = queue.poll();\n            for (Node child : curr.children) {\n                if (!visited.contains(child)) {\n                    queue.add(child);\n                    visited.add(child);\n                }\n            }\n        }\n        level++;\n    }\n}\n```\n*Level-order traversals differ from BFS because they keep track of what \"step\" of the BFS we're currently on. This can be handy for problems where we want to know the length of the shortest path, like [Word Ladder](https://leetcode.com/problems/word-ladder/) or [Rotting Oranges](https://leetcode.com/problems/rotting-oranges/)*.\n\n","lastmodified":"2022-05-22T06:03:58.249408405Z","tags":null}}